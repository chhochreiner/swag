«IMPORT metamodel»

«EXTENSION template::GeneratorExtensions»

«DEFINE main FOR Model»
	«EXPAND javaClass FOREACH entities()»
	«EXPAND javaEnum  FOREACH enums()»

	«EXPAND persistenceUnit FOR this»
	«EXPAND hackyHelper     FOR this»	
«ENDDEFINE»

«DEFINE javaClass FOR Entity»
	«FILE "java/" + package() + "/domain/" + name + ".java"»
		package «package()».domain;

		import java.util.*;
		import javax.persistence.*;
	
		@Entity
		@Table(
			name="«tableName()»",
			uniqueConstraints={
				«FOREACH attributes.select(a|a.unique) AS attr SEPARATOR ", \n"»
					@UniqueConstraint(columnNames={"«attr.name»"})
				«ENDFOREACH»
			}
		)
		public class «name» extends AbstractEntity {
			//*** constructors
			
			public «name»() {/**/}
			
			«IF fields().exists(f|f.nullable)»
				public «name»(«FOREACH fields().select(f|f.nullable) AS f SEPARATOR ", "»«f.typeName()» «f.name»«ENDFOREACH») {
					«FOREACH fields().select(f|f.nullable) AS f»
						this.«f.name» = «f.name»;
					«ENDFOREACH»
				}
			«ENDIF»
		
			//*** getters
			«FOREACH attributes AS attr»
				@Basic( optional = «attr.nullable» )
				«IF attr.type.name == "Date"»
					@Temporal(TemporalType.TIMESTAMP)
				«ENDIF»
				«IF model().enums().contains( attr.type )»
					@Enumerated(EnumType.STRING)
				«ENDIF»
				public «attr.typeName()» «attr.getter()»() {
					return «attr.name»;
				}
			«ENDFOREACH»
			
			«FOREACH associations AS assoc»
				@«assoc.multiplicity»«IF assoc.isMapped()»( mappedBy="«assoc.mappedBy()»" )«ENDIF»
				public «assoc.typeName()» «assoc.getter()»() {
					«IF assoc.multiplicity == Multiplicity::ManyToMany || assoc.multiplicity == Multiplicity::OneToMany»
						if ( «assoc.name» == null ) «assoc.name» = new «assoc.concreteType()»();
					«ENDIF»

					return «assoc.name»;
				}
			«ENDFOREACH»
			
			//*** setters
			«FOREACH fields() AS f»
				public void «f.setter()»(«f.typeName()» «f.name») {
					this.«f.name» = «f.name»;
				}
			«ENDFOREACH»
			
			//*** alternate setters which allow method chaining
			
			«FOREACH fields() AS f»
				public «name» «f.name»(«f.typeName()» «f.name») {
					this.«f.name» = «f.name»;
					return this;
				}
			«ENDFOREACH»
			
			//*** misc
			
			public String toString() {
				return 
					"«name»[" +
						«FOREACH fields().sortBy(e|e.name) AS f SEPARATOR " + \", \" + "»
							"«f.name»: " + toString( «f.getter()»() )
						«ENDFOREACH»
					+ "]"
				;
			}
			
			//*** PRIVATE PARTS
			«FOREACH fields() AS f»
				private «f.typeName()» «f.name»;
			«ENDFOREACH»
		}
	«ENDFILE»
	«FILE "java/" + package() + "/dao/" + name + "DAO.java"»
		package «package()».dao;
		
		import java.util.Date;
		import java.util.List;
		import javax.persistence.EntityManager;
		
		import «package()».domain.*;
		
		public class «name»DAO extends AbstractDAO<«name»> {
			public «name»DAO( EntityManager em ) {
				super( em );
			}

			@SuppressWarnings("unchecked")
			public List<«name»> findAll() {
				return getEntityManager().createQuery( "SELECT obj FROM «name» obj" ).getResultList();
			}

			«FOREACH attributes AS attr»
				«IF attr.unique»
					@SuppressWarnings("unchecked")
					public «name» findBy«attr.name.toFirstUpper()»( «attr.type.name» «attr.name» ) {
						return («name») getEntityManager().createQuery(
							"SELECT obj FROM «name» obj WHERE obj.«attr.name» = :val" )
							.setParameter( "val", «attr.name» )
							.getSingleResult();
					}
				«ELSE»
					@SuppressWarnings("unchecked")
					public List<«name»> findBy«attr.name.toFirstUpper()»( «attr.type.name» «attr.name» ) {
						return getEntityManager().createQuery(
							"SELECT obj FROM «name» obj WHERE obj.«attr.name» = :val" )
							.setParameter( "val", «attr.name» )
							.getResultList();
					}
				«ENDIF»
			«ENDFOREACH»

			protected Class<«name»> getEntityClass() {
				return «name».class;
			}
		}		
	«ENDFILE»
«ENDDEFINE»

«DEFINE javaEnum FOR EnumType»
	«FILE "java/" + package() + "/domain/" + name + ".java"»
		package «package()».domain;
	
		public enum «name» {
			«values»;
		}
	«ENDFILE»
«ENDDEFINE»

«DEFINE persistenceUnit FOR Model»
	«FILE "resources/META-INF/persistence.xml"»
		<persistence
			xmlns              = "http://java.sun.com/xml/ns/persistence"
			xmlns:xsi          = "http://www.w3.org/2001/XMLSchema-instance"
			xsi:schemaLocation = "http://java.sun.com/xml/ns/persistence
	                          http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd" 
			version            = "1.0">

			<persistence-unit name="«package»">
				<provider>org.hibernate.ejb.HibernatePersistence</provider>
	
				«FOREACH entities() AS e»
					<class>«package».domain.«e.name»</class>
				«ENDFOREACH»
	
				<properties>
					<!-- Database connection settings -->
					<property name="hibernate.connection.driver_class" value="org.postgresql.Driver"/>
					<property name="hibernate.connection.url"          value="jdbc:postgresql://localhost/swa"/>
					<property name="hibernate.connection.username"     value="swa" />
					<property name="hibernate.connection.password"     value="swa11" />
	
					<!-- JDBC connection pool (use the built-in) -->
					<property name="hibernate.connection.pool_size" value="1" />
		
					<!-- SQL dialect -->
					<property name="hibernate.dialect" value="org.hibernate.dialect.PostgreSQLDialect" />

					«IF logSQL»
						<!-- Echo all executed SQL to stdout -->
						<property name="hibernate.show_sql" value="true" />
					«ENDIF»

					«IF autocreateDatabaseSchema»
						<!-- Drop and re-create the database schema on startup -->
						<property name="hibernate.hbm2ddl.auto"            value="update" />
						<property name="javax.persistence.validation.mode" value="none" />
					«ENDIF»
				</properties>
			</persistence-unit>
		</persistence>
	«ENDFILE»
«ENDDEFINE»

«DEFINE hackyHelper FOR Model»
	«FILE "java/" + package + "/Helper.java"»
		package «package»;
		
		import javax.persistence.*;
		
		public abstract class Helper {
			public static void dropDatabase( EntityManager em ) {
				EntityTransaction tx = em.getTransaction();
				tx.begin();
			
				«FOREACH entities() AS e»
					em.createNativeQuery("DROP TABLE «e.tableName()» CASCADE").executeUpdate();					
				«ENDFOREACH»
				
				tx.commit();
			}
		}
	«ENDFILE»
«ENDDEFINE»
